# 束縛の表現について
ラムダ計算の実装は主に束縛関係がめんどくさい。
- 代入
- $\alpha$ 同値、 $\alpha$ 変換
これらを正しく実装するのは難しい。

まず普通のラムダ項を考えたとする。
代入で一番気を付けるのは $M[x := N]$ に対して、 $N$ の自由だった変数が $M$ の束縛変数と被っていてはいけないということ。
- アルファ変換（束縛変数と自由変数を被らないようにする変換）ができれば、代入ができる。
- 代入が実装できればアルファ同値の判定や変換も楽にできる。

### 束縛回避代入 (capture-avoiding)
$x \not = y$ かつ $y \notin \text{FV}(N)$ なら $(\lambda y. t)[x := N] = \lambda y. (t [x := N])$ としてよい。
この条件だけ守ればいいが、この条件が満たされない場合にどうするかは、$\alpha$ 変換を用いることになるので、
$\alpha$ 変換の定義をするか、あるいは $\lambda z. t[y := z]$ と考えるとよい。
ただし、 $z \notin \text{FV}(N)$ を1つとってくる。

## de Bruijn 表現
$\lambda$ への相対的な関係を数字にすればいいというアイディア。
この場合、アルファ同値がほぼ一意になる。
ただ、自由変数についての議論はよくわからないのでこれは採用しない。

## locally nameless
束縛部分を数字にして、自由変数はふつうの変数にする。
ただしいくつか考慮する点がありそう。
1. ユーザーの入力時の束縛の名前が保存されていないと辛い。

やり方としては、
```
data Var :=
| FVar of string
| BVar of int

data term :=
| Var of var
| Abs of string * term
| App of term * term
```
のようにする。
ただし、 Abs のときに束縛変数の名前についての情報を導入している。
