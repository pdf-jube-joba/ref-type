# 動機
数学の文章として、機械的に検証可能かつ人間に読みやすいものが欲しい。
- Core calculus のレベルでどうにかしないといけない部分
- syntax sugar みたいなものと考えられる部分

ここでは、 Core calculus っぽい部分について。
- より自然に property に関する subtyping が使える
  - $2$ が自然数でもあり偶数でもある。
    - Coq の場合は $2$ と $2$ が偶数であることの証明の組が偶数として型付けされる。
  - 部分集合が本当に部分集合になり、キャストが簡単（書かなくていい）
    - これは難しかった。証明項だけなくせるならいいか。
    - 結果として型付けの一意性はないと思うけど、それでもいい
- 証明項を真に区別する必要がない or 証明項を扱わなくてよい
  - 群が等しいとは群の演算が等しいこと、証明項まで等しいこととみなしたくない
  - 証明項を構成することもできるが、それの存在を覚えておくだけぐらいでいい
  - あと関数の外延性などの axiom をいい感じにしたい
- well-definedness や等式の話をもっと簡単に扱いたい
  - 商写像の扱いのような、"取り方によらない構成"を書きたい。
- べき集合が欲しい

他に欲しいもの
- non-structural な再帰関数を"そのまま"受け入れることができるようにしたい。
  - 関数の定義の中に停止性の証明を書かずに、関数の定義とは別で停止性の証明を書きたい。
- universe level polymorphism みたいなのを、level についての関数以外の形で書く。
  - type in type ができる部分を用意して、 consistent な部分だけ持ってくるとか。
  - 発想は、対応する structural recursion が書ける non-structural recursion を項として受け入れるのと同じ。
  - ある種の "templete 元" からの instantiation を、 calculus のレベルで定義しておきたい。

# ほしい機能の実現
## 証明と証明項の抽象化
$P: *^p$ に対して $t: P$ の項を区別する必要はなく、存在することだけ取り出せればよいはず。
- $\Gamma \vDash P$ を 「$\Gamma$ の下で $P$ が証明可能」を表すように導入する。
- $\Gamma \vDash P$ ならその証明項として $\Proof P$ をもって $\Gamma \vDash t: P$ なる $t$ のように扱う。

## refinement type と power type と predicate の導入
"集合" $A$ に対して $\{x: A \mid P\}$ や $\Power A$ が書けるとうれしい。
さらに、 $\{x: A \mid P\}$ から述語が取り出せた方が扱いやすい。
このため、 $\Pred(A, B, t)$ という項を入れて、 $\Pred(A, \{x: B \mid P\}, t) \to_\beta (\lambda x: B. P) @ t$ のように関係を導入する。
こうすれば、一般の $A$ と $B$ に対して、 $t: A$ が $t: B$ になる条件を記述できる。
ただし、 term のレベルと type のレベルを合わせたいので次のような感じにしている。
| 説明 | term level | type level |
| --- | --- | --- |
| 普通の項 | $t$ | $A$ |
| Power set の元 | $\{x: A \mid P\}, B$ | $\Power A$ |
| subset 関係 | $t$ | $\Ty (A, \{x: A \mid P\}), \Ty (A, B)$ |

## definite description について
商集合を扱うことができるようになったので、これをさらに便利にするために、 quotient のようなことができるとうれしい。
一応すでに商集合自体は記述ができるが、写像を記述することが難しい。
これを動機として、 $\Take T$ を $T$ が空でなくかつ元が1つしかない場合に $T$ の元とする。
これの正当性を記述するために $=$ や"元の存在"が必要になる。

# 現状の課題（体系）
総じて、記述のための universe 以外に、 computation のための universe が欲しいということに見える。
（というかそれ用に `rust` 側で用意していたのだった。）

- $*^s_{i}: *^s_{i+1}$: ちゃんとした数学のための厳密な universe
  - 項が computational じゃなくても、 canonical じゃなくてもよい
  - 再帰にはちゃんとした well-foundedness を要求する側
- $*^c$: 
  - 項が（基本的には） computational になっている。
  - $*^s$ 側で見たときに停止するなら、厳密な recursion の形をしていなくてもいい。
  - マクロやメタプログラミングのような、コード自体を扱えてほしい。

## non-structural recursion がほしい。
全てが structural recursion や recursor による記述だとつらい。
proof-term の存在が示せればよかったように、普通の rec も、 upper bound が存在することが示せれば、
structural recursion になっていなくても項として受け入れたほうがいい。

## universe level polymorphism について
構造として $X: *^s_{i}$, $\mu: X \times X \to X$ の組を考えてみる。
このとき $(X, \mu): (X: *^s_{i}) \times (X \times X \to X): *^s_{i+1}$ のようになるが、
このレベルが上がるのは仕方がない。
（これをやるにはさらに $(*^s_{i+1}, *^s_{i}, *^s_{i+1}) \in \mathcal{R}$ とか cumulative （$T: *^s_i \implies T: *^s_{i+1}$）が必要になるが、そこは本題じゃない。）
理由は、「台集合 $\subset *^s_i$ とその上の二項演算の組」の集合を考えればそれが $*^s_i$ には入らないのは当然だから。
ただここでの問題は、そうなると、定義を universe ごとに繰り返さなければいけないこと。
例えば群を例にすれば、 $*^s_{0}, *^s_{1}, *^s_{2}$ それぞれで帰納的な型やレコード型として定義する必要がある。
これはめんどくさいので、 universe level を受け取っての定義ができるとうれしいが、もっと根本的に解決できないか。
