core calculus としては Exp しかないものを考えるが、
数学文章用としてはそれでは弱い。
文章（群）としての仕様について考える。
形式的にこう書けたらいいというのを書いてみる。

# 既存の数学文書について
読みやすさの形式化を考えるために、いろんなシチュエーションを考えたい。

## $\sqrt{2}$ の無理性
> もし $\sqrt{2}$ が有理数なら、整数 $a, b$ であって、
> $a^2 = 2 b^2$ かつ $a$ と $b$ は互いに素となる物が存在する。
> $a^2$ は偶数であるから $a$ は偶数である。
> 整数 $a'$ をとって $a = 2 a'$ とすると $2 a'^2 = b^2$ が成り立つ。
> $b^2$ は偶数であるから $b$ も偶数であるので、 $a$ と $b$ が互いに素という仮定に矛盾する。
> よって、 $\sqrt{2}$ は有理数ではない。

これを形式化するとすごい長くなる。
『the seventeeen provers』 のベンチマークとして使われた。

## 数学的構造の台集合とオーバーロード
> 群とは、次の構造のこと
> - 台集合 $G$
> - 二項演算 $\mu$: $G \times G \to G$
> - 単位元 $1$: $G$
> - 逆元 $(\bullet)^{-1}$: $G \to G$
> - 結合律： $\forall a, b, c: G, \mu(\mu(a, b), c) = \mu(a, \mu(b, c))$
> - 単位元の性質 $\forall a: G, \mu(1, a) = a = \mu(a, 1)$
> - 逆元の性質： $\forall a: G, \mu(a, a^{-1}) = 1 = \mu(a^{-1}, a)$
>
> 群 $G$ の部分群とは、 $G$ の部分集合で $H$ であって、
> $a, b \in H \implies \mu(a, b) \in H$ を満たし、この演算により $H$ が群となるもののことを言う。
> またこのとき、 $H$ を $G$ の演算 $\mu$ の制限により群とみなす。

実際に書かれる定義だと、単位元は存在で書かれて逆元のところでとくに断りなしで出てくることが多い。

- 台集合と数学的構造を同一視している。
- $1$ や $(\bullet)^{-1}$ は異なる群でも共通の書き方をするので、オーバーロードしている。
- 部分群の定義でも、"制限により群とみなす" において集合と構造を同一視する。

演算のオーバーロードの話として、
$a * b$ は $a \in X$ となる $X$ を**考えずに**一意に定まってほしい気持ちがある。
型付けが一意な状況ならともかく、文脈をもとに $a$ が何であるかのみによって規定されていてほしい？

## 同型の計算
幾何の代数不変量だと、あまり同型を気にしないことがあり、同型の取り方を後から議論しても間に合うことも多い。
> $H_1(M; \mathbb{Z}) = \mathbb{Z}$

のような書き方とか。

## $=$ の両辺を必要に応じて制限する
微分形式についての主張だと、
座標をとって行列が出てくるような話の場合には、
$\omega = \omega _1 \wedge \omega _2$ みたいなものは、
それぞれの定義域を好きなだけ狭めての定義になる。

# ほしいプログラミングとしての機能
## オーバーロードのために
Trait のようなものはほしい。
- dot notation (`a: T: Trait` について `a.method()`)
- associate method (`T: Trait` について `T::method()`)
- notation (`T: Specific-Trait` のときにのみ `a method b` など。)

普通に部分集合に Trait を定義することになると、
型の一意じゃなさと合わさってどの演算を使うかの解決が難しい。
なので、ある程度一意に定まる名前が付けられるようになった方がいい。
また、台は必ず集合と考えて、合成できるようにするのがいい？
それと、演算子と Trait を結び付けられるといい。
（ rust の std::ops のような感じ。）

## 名前空間を分ける
module についての扱いをどうするか。
module の中で宣言されている変数に代入ができないといけない。

# 検証器の仕様について
部分集合がある時点で証明項を与えられてもそれで解決とはいかない。
ただ、導出木を書かせるのも意味がないので、
できる限り導出木の雰囲気に近いアルゴリズムと検査器に読ませる形式文法を考えないといけない。

- 導出木の展開を考えるうえで、同じ証明を作らないといけなくなるとつらい。
  - 例えばふつうに実装したら、
    $\text{id} = \lambda X: *^s, \lambda x: X, x: (X: *^s) \to X \to X$ に対して、
    $A: *^s, a: A \vdash \text{id} \{A \mid \top\} (\text{id} \{A \mid \top\} a)$ の検査時に $2$ 回 $\top$ を証明する必要が出てくるようになってしまう。
  - また、 $A: *^s, B: \Pow A, x: \Ty(B)$ とわかっているのに、 $ \vdash x: \Ty(B)$ の導出木を $\vdash x: A$ からやって $\vDash \Pred(A, B, x)$ を要求するようなら、
    とってもめんどくさい。

- 検証器は展開時に木構造じゃなくて DAG で judgement の関係を保持する。
- provability の場合には、 $\beta$ modulo を加味して保持する。
- すでにあるかどうかを検査する？
