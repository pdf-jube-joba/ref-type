core calculus としては Exp しかないものを考えるが、
数学文章用としてはそれでは弱い。
文章（群）としての仕様について考える。
形式的にこう書けたらいいというのを書いてみる。

# 既存の数学文書について
読みやすさの形式化を考えるために、いろんなシチュエーションを考えたい。

## $\sqrt{2}$ の無理性
> もし $\sqrt{2}$ が有理数なら、整数 $a, b$ であって、
> $a^2 = 2 b^2$ かつ $a$ と $b$ は互いに素となる物が存在する。
> $a^2$ は偶数であるから $a$ は偶数である。
> 整数 $a'$ をとって $a = 2 a'$ とすると $2 a'^2 = b^2$ が成り立つ。
> $b^2$ は偶数であるから $b$ も偶数であるので、 $a$ と $b$ が互いに素という仮定に矛盾する。
> よって、 $\sqrt{2}$ は有理数ではない。

これを形式化するとすごい長くなる。
『the seventeeen provers』 のベンチマークとして使われた。

## 数学的構造の台集合とオーバーロード
> 群とは、次の構造のこと
> - 台集合 $G$
> - 二項演算 $\mu$: $G \times G \to G$
> - 単位元 $1$: $G$
> - 逆元 $(\bullet)^{-1}$: $G \to G$
> - 結合律： $\forall a, b, c: G, \mu(\mu(a, b), c) = \mu(a, \mu(b, c))$
> - 単位元の性質 $\forall a: G, \mu(1, a) = a = \mu(a, 1)$
> - 逆元の性質： $\forall a: G, \mu(a, a^{-1}) = 1 = \mu(a^{-1}, a)$
>
> 群 $G$ の部分群とは、 $G$ の部分集合で $H$ であって、
> $a, b \in H \implies \mu(a, b) \in H$ を満たし、この演算により $H$ が群となるもののことを言う。
> またこのとき、 $H$ を $G$ の演算 $\mu$ の制限により群とみなす。

実際に書かれる定義だと、単位元は存在で書かれて逆元のところでとくに断りなしで出てくることが多い。

- 台集合と数学的構造を同一視している。
- $1$ や $(\bullet)^{-1}$ は異なる群でも共通の書き方をするので、オーバーロードしている。
- 部分群の定義でも、"制限により群とみなす" において集合と構造を同一視する。

演算のオーバーロードの話として、
$a * b$ は $a \in X$ となる $X$ を**考えずに**一意に定まってほしい気持ちがある。
型付けが一意な状況ならともかく、文脈をもとに $a$ が何であるかのみによって規定されていてほしい？

## 同型の計算
幾何の代数不変量だと、あまり同型を気にしないことがあり、同型の取り方を後から議論しても間に合うことも多い。
> $H_1(M; \mathbb{Z}) = \mathbb{Z}$

のような書き方とか。
これは取り組むのが難しいのでちょっと置いておく。

## $=$ の両辺を必要に応じて制限する
微分形式についての主張だと、
座標をとって行列が出てくるような話の場合には、
$\omega = \omega _1 \wedge \omega _2$ みたいなものは、
それぞれの定義域を好きなだけ狭めての定義になる。

## "$X$ 上の空間" のような概念
まず、位相構造と台集合を同一視する。
空間 $X$ に対して、　空間 $Y$ と $f$: $Y \to X$ の組を考えるときに、
$Y$ をもって $(Y, f)$ の組と考えることがある。
このときに $f$ を $\pi_Y$ と書いたり。
こんな感じの議論：

> $Y_1, Y_2$: $X$ 上の空間に対して、 $f$: $Y_1 \to Y_2$ であって 
> $\pi_{Y_2} \circ f = \pi_{Y_1}$ を満たすものを $X$ 上の空間の間の写像という。

他には、基点付き集合とかある。

# ほしいプログラミングとしての機能
## オーバーロードのために
引数を全部明示的に与えるのはつらいので、文脈からうまく埋めることができるとうれしい。
例として、 $a * b$ を $a$ の型から $*$ でどの実装を使うかを当ててほしい。

## 名前空間を分ける
module についての扱いをどうするか。
1. module の中で宣言されている変数に代入ができないといけない。
2. module は入れ子にできないと、コードを書くのが難しい。

# 検証器の仕様について
部分集合がある時点で証明項を与えられてもそれで解決とはいかない。
ただ、導出木を書かせるのも意味がないので、
できる限り導出木の雰囲気に近いアルゴリズムと検査器に読ませる形式文法を考えないといけない。

- 導出木の展開を考えるうえで、同じ証明を作らないといけなくなるとつらい。
  - 例えばふつうに実装したら、
    $\text{id} = \lambda X: *^s, \lambda x: X, x: (X: *^s) \to X \to X$ に対して、
    $A: *^s, a: A \vdash \text{id} \{A \mid \top\} (\text{id} \{A \mid \top\} a)$ の検査時に $2$ 回 $\top$ を証明する必要が出てくるようになってしまう。
  - また、 $A: *^s, B: \Power(A), x: \Ty(B)$ とわかっているのに、 $ \vdash x: \Ty(B)$ の導出木を $\vdash x: A$ からやって $\vDash \Pred(A, B, x)$ を要求するようなら、
    とってもめんどくさい。
  - DAG を作るほうがいい。 up alpha conversion を無視したほうがいいので、この点でも locally nameless が楽になる。
- 検証器は展開時に木構造じゃなくて DAG で judgement の関係を保持する。
- provability の場合には、 $\beta$ modulo を加味して保持する。
  - すでにあるかどうかを検査する？...normalize すると停止しなくなるので、 Prop かどうかを検査すること。
- $\vDash P$ の導出に何を使うかがユーザーに指定できないといけない。
  - 現在の分
    - $\vDash P$ if $\vdash p: P$ ... \exact p か、何も言わずに `p` とするとか。
    - $\vDash \Pred(A, B, t)$ if $\vDash B: \Power A, \vDash t: \Ty(A, B)$ ... \subset t A B
    - $\vDash a = a$ ... \refl a
    - $\vDash P @ a$ if $\vdash P: A -> *^p, $ ... \id-elim a b P
    - $\vDash \Take f = t$ if $\Take f: T$ ... \take-eq f t T
- その他 axiom の分 `\axiom:{hoge}` みたいな感じで。
  - law of excluded middle: $\vDash (P: *^p) \to (P \vee \gen P)$ ... `\axiom:LEM`
  - set extensionality: $\vDash (X: *^s) \to (Y_1, Y_2: \Power X) \to ((z: X) \to \Pred(X, Y_1, z) \leftrightarrow \Pred(X, Y_2, z)) \to Y_1 = Y_2$ ... `\axiom:SE`
  - function extensionality: $\vDash (X, Y:*^s) \to (f_1, f_2: X \to Y) \to ((x: X) \to f_1 x = f_2 x) \to f_1 = f_2$ ... `\axiom:FE`
