core calculus としては term しかないものを考えるが、
数学文章用としてはそれでは弱い。
文章（群）としての仕様について考える。
形式的にこう書けたらいいというのを書いてみる。

このページではメモを書いておいて、これ以降のページでは構文とコード例をのせる。

# 既存の数学文書について
読みやすさの形式化を考えるために、いろんなシチュエーションを考えたい。

## $\sqrt{2}$ の無理性
> もし $\sqrt{2}$ が有理数なら、整数 $a, b$ であって、
> $a^2 = 2 b^2$ かつ $a$ と $b$ は互いに素となる物が存在する。
> $a^2$ は偶数であるから $a$ は偶数である。
> 整数 $a'$ をとって $a = 2 a'$ とすると $2 a'^2 = b^2$ が成り立つ。
> $b^2$ は偶数であるから $b$ も偶数であるので、 $a$ と $b$ が互いに素という仮定に矛盾する。
> よって、 $\sqrt{2}$ は有理数ではない。

これを形式化するとすごい長くなる。
『the seventeeen provers』 のベンチマークとして使われた。

## 数学的構造の台集合について
数学的構造をその台集合と同一視することが多い。

> 群とは、次の構造のこと
> - 台集合 $G$
> - 二項演算 $\mu$: $G \times G \to G$
> - 単位元 $1$: $G$
> - 逆元 $(\bullet)^{-1}$: $G \to G$
> - 結合律： $\forall a, b, c: G, \mu(\mu(a, b), c) = \mu(a, \mu(b, c))$
> - 単位元の性質 $\forall a: G, \mu(1, a) = a = \mu(a, 1)$
> - 逆元の性質： $\forall a: G, \mu(a, a^{-1}) = 1 = \mu(a^{-1}, a)$
>
> 群 $G$ の部分群とは、 $G$ の部分集合で $H$ であって、
> $a, b \in H \implies \mu(a, b) \in H$ を満たし、この演算により $H$ が群となるもののことを言う。
> またこのとき、 $H$ を $G$ の演算 $\mu$ の制限により群とみなす。

これの問題点（？）は以下：
- 台集合と数学的構造を同一視している。
- $1$ や $(\bullet)^{-1}$ は異なる群でも共通の書き方をするので、オーバーロードしている。
- 部分群の定義でも、"制限により群とみなす" において集合と構造を同一視する。

他の例：例えば、コホモロジー $H^n(X; \mathbb{Z} / 2 \mathbb{Z})$ は、
集合でありアーベル群であり環であり、 $\mathbb{Z} / 2 \mathbb{Z}$ 加群であり ...
のように際限がない。

イメージ的には、次の二つがある。
1. rust の trait とか（ haskell の型クラス） のように、集合に対して、関連づけられた構造を追加していく
  - $H^n (X; \mathbb{Z} / 2)$ という集合があって、宣言するごとにこれに構造を結び付けていく。
2. 数学的構造への名前付けがあって、これを台集合に忘却する。
  - $(H^n (X; \mathbb{Z} / 2))_{\text{set}}$ という集合、 $(H^n (X; \mathbb{Z} / 2))_{\text{ab}}$ という群構造 ... に対して、
    $H^n (X; \mathbb{Z} / 2)$ という書き方は許されず、集合が入るところに群が来たら集合に忘却する。

他の案でいいのか思いつかなかったので、両方を混ぜて、構造への名前つけと、集合と構造の結び付けの宣言を行う方式にする。

$H^n (X; \mathbb{Z} / 2)$ は集合と考え、 $H^n (X; \mathbb{Z} / 2)_{\text{ab}}$ という群構造を別に宣言する。
$\text{Group structure for } H^n (X; \mathbb{Z} / 2) := H^n (X; \mathbb{Z} / 2)_{\text{ab}}$ という宣言があると、
以降は $H^n (X; \mathbb{Z} / 2)$ が群構造が来るべきところに書かれていたら、 $H^n(X; \mathbb{Z} / 2)_{\text{ab}}$ を
（**検証器が**宣言をもとに）選び出して代入する。

## 演算子とオーバーロード
一般の群についての議論をする場合に $*$ という記号を使う場合と、単に自然数の積をもって $*$ を使う場面がある。
同じ記号を使っているが、文脈によって適切に解釈してほしい。
また、 $a * b$ は $a \in X$ となる $X$ を**考えずに**一意に定まってほしい気持ちがある。
（これは coference が成り立つみたいな話？）
型付けが一意な状況ならともかく、文脈をもとに $a$ が何であるかのみによって規定されていてほしいと思う。

# ちょっと考えが及ばないところ
今は対処が難しいので、書くだけ書いておく。

## 同型の計算
幾何の代数不変量だと、あまり同型を気にしないことがあり、同型の取り方を後から議論しても間に合うことも多い。
なので、「どのように同型か」という情報は忘れて「同型である」だけを気にするような書き方が多い。

> $H_1(M; \mathbb{Z}) = \mathbb{Z}$

のような書き方とか。
「どのように同型か」は構造だけど、「同型である」は性質なので、
同型であることだけをもとに定義を組み立てるのは、 well-definedness を議論する必要があったりする。

線形空間の例：
$V \cong \mathbb{R}^n$ がわかっていたとして $V \overset{f}{\to} V$ のトレースの定義を
「同型 $\phi$: $V \to \mathbb{R}^n$ を用いて $\text{tr} \phi \circ f \circ (\phi^{-1})$ とする。」
は、 well-definedness の議論が必要になる。

## $=$ の両辺を必要に応じて制限する
微分形式についての主張だと、
座標をとって行列が出てくるような話の場合には、
$\omega = \omega _1 \wedge \omega _2$ みたいなものは、
それぞれの定義域を好きなだけ狭めての議論になる。

# ほしいプログラミングとしての機能
## 名前空間を分ける
当然コードを分割する必要がある。
また、分割は入れ子にできないと厳しい。
これの単位を module としておいて、どう扱うかを考えたい。

- Coq だと variable や parameter や axiom が文中に書けるけど、これは読みづらくなるのでやめる。
  そういうパラメータ的なものは `module` の引数として最初に集中させておく。
- 他の module を使う場合も同様に、何に使うかの宣言は最初に集中させておく。
- 内部から使う場合は代入を全部する。
- 代入した module に名前を付けることができるようにする。
- module の拡張もできるようにする：`A extend B` と書いたら、 `A` での宣言が使える。

## マクロや notation について
ユーザーがトークンの列を処理することができるといい。
例えば、
```
reasoning!{
  P1 & h1
  ==> P2 & h2
  ==> P3 & h3
}
```
は Prop `P1` から Prop `P3` をどう導出すればいいか記述しているが、
これを `((h3: P2 -> P3) (h2: P1 -> P2) (h1: P1)): P3` に変形するマクロが、**ユーザーにも**書けるとうれしい。
このマクロを記述する言語はできれば、外部のツールとしてではなく、内部の言語として書かれていたほうが、
インターネットでは保存がきく。

また、ユーザーが直接トークンの列をいじるのではなくて、単に記法を定義するだけの部分もあった方がいい。
prefix/infix/postfix や associativity の指定**ではなくて**、「この列があったらこう変形して」を指定する。
また、そのような特別な記法を用いる場所はマークする。
例：
- `add 1 2` が普通だが、 `$( 1 + 2 $)` とも書ける
- `$( 1 + 2 + 3 $)` は associative の指定はなしに、適当に戦略をこちらで決め打ちする。例えば、初めに見つかった `'exp` でないようなトークンから宣言を逆引きするとか。
  - 次のように解釈される： `+` が $2$ 番目にあるので宣言の中に `expr0 + expr1 => {hoge}` があるかを探し、一番初めに見つかったものを使って展開する： `add 1 $( 2 + 3 $)`
- ちゃんと結合を指定したいときは常にかっこでくくる： `$( 1 + (add 2 3) $)`
- あるいは、 `$($)` を使ってもいい： `$( 1 + $( 2 + 3 $) $)`
- もうちょっと複雑なこともできる： `! expr0 ? expr1 : expr 2 => {hoge}` とか

# 検証器の仕様や実装側について
部分集合がある時点で、項と型を与えられても導出木が全部導出できるわけではない。
ただ、導出木を書かせるのも意味がないので、
できる限り導出木の雰囲気に近いアルゴリズムと検査器に読ませる形式文法を考えないといけない。
また、どこで証明が必要な部分が発生するのかがわかりやすいほうがいい。

- 導出木の展開を考えるうえで、同じ証明を作らないといけなくなるとつらい。
  - 例えばふつうに実装したら、
    $\text{id} = \lambda X: *^s, \lambda x: X, x: (X: *^s) \to X \to X$ に対して、
    $A: *^s, a: A \vdash \text{id} \{A \mid \top\} (\text{id} \{A \mid \top\} a)$ の検査時に $2$ 回 $\top$ を証明する必要が出てくるようになってしまう。
  - また、 $A: *^s, B: \Power(A), x: \Ty(B)$ とわかっているのに、 $ \vdash x: \Ty(B)$ の導出木を $\vdash x: A$ からやって $\vDash \Pred(A, B, x)$ を要求するようなら、
    とってもめんどくさい。
  - DAG を作るほうがいい。 up alpha conversion を無視したほうがいいので、この点でも locally nameless が楽になる。
  - 検証器は展開時に木構造じゃなくて DAG で judgement の関係を保持する。
- provability の場合には、 $\beta$ modulo を加味して保持する。
  - すでにあるかどうかを検査する？...normalize すると停止しなくなる可能性を考慮する必要がある： Prop かどうかを検査すれば大丈夫そう。
- $\vDash P$ の導出に何を使うかがユーザーに指定できないといけない。
  - 証明が要求される部分で適宜ユーザーが証明を与えるための文法が必要。
- checker の前にパースの時点でいろいろな処理をする：
  - 内部での表現は locally nameless にしておく。
    - 束縛変数の名前と、束縛される部分を覚えておく。
      - subset やら exist やらも含めて。
      - ind-elim のところも vec で引数をとっておく。
    - つまり、パースの時点で、局所的な話じゃなくなる。
  - 各 module では、
    - 引数の型をチェックしたあとは、 context のスタックに積む
    - 内部で definition や theorem があるたびに覚えておき、一度チェックしたら二度とチェックしない。
  - ある名前がほかの module を指しているのか definition などの定義を指しているのかも検査する。
    - 意味解析の中で、 module と variable のどっちかを調べるところまでやる。
- module と同値性について
  - ある module `A (B: Set)` の中に `Id` があったとして、 `A(B := C).Id = A(B := D).Id` が示せるかどうか？
  - module の content になっている時点で代入して比較はできる ... やってよいことにする。
