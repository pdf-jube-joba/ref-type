core calculus としては term しかないものを考えるが、
数学文章用としてはそれでは弱い。
文章（群）としての仕様について考える。
形式的にこう書けたらいいというのを書いてみる。

このページではメモを書いておいて、これ以降のページでは構文とコード例をのせる。

# 既存の数学文書について
読みやすさの形式化を考えるために、いろんなシチュエーションを考えたい。

## $\sqrt{2}$ の無理性
> もし $\sqrt{2}$ が有理数なら、整数 $a, b$ であって、
> $a^2 = 2 b^2$ かつ $a$ と $b$ は互いに素となる物が存在する。
> $a^2$ は偶数であるから $a$ は偶数である。
> 整数 $a'$ をとって $a = 2 a'$ とすると $2 a'^2 = b^2$ が成り立つ。
> $b^2$ は偶数であるから $b$ も偶数であるので、 $a$ と $b$ が互いに素という仮定に矛盾する。
> よって、 $\sqrt{2}$ は有理数ではない。

これを形式化するとすごい長くなる。
『the seventeeen provers』 のベンチマークとして使われた。

## 数学的構造の台集合について
数学的構造をその台集合と同一視することが多い。

> 群とは、次の構造のこと
> - 台集合 $G$
> - 二項演算 $\mu$: $G \times G \to G$
> - 単位元 $1$: $G$
> - 逆元 $(\bullet)^{-1}$: $G \to G$
> - 結合律： $\forall a, b, c: G, \mu(\mu(a, b), c) = \mu(a, \mu(b, c))$
> - 単位元の性質 $\forall a: G, \mu(1, a) = a = \mu(a, 1)$
> - 逆元の性質： $\forall a: G, \mu(a, a^{-1}) = 1 = \mu(a^{-1}, a)$
>
> 群 $G$ の部分群とは、 $G$ の部分集合で $H$ であって、
> $a, b \in H \implies \mu(a, b) \in H$ を満たし、この演算により $H$ が群となるもののことを言う。
> またこのとき、 $H$ を $G$ の演算 $\mu$ の制限により群とみなす。

これの問題点（？）は以下：
- 台集合と数学的構造を同一視している。
- $1$ や $(\bullet)^{-1}$ は異なる群でも共通の書き方をするので、オーバーロードしている。
- 部分群の定義でも、"制限により群とみなす" において集合と構造を同一視する。

他の例：例えば、コホモロジー $H^n(X; \mathbb{Z} / 2 \mathbb{Z})$ は、
集合でありアーベル群であり環であり、 $\mathbb{Z} / 2 \mathbb{Z}$ 加群であり ...
のように際限がない。

イメージ的には、次の二つがある。
1. rust の trait のように、集合に対して、関連づけられた構造を追加していく
  - $H^n (X; \mathbb{Z} / 2)$ という集合があって、宣言するごとにこれに構造を結び付けていく。
2. 数学的構造への名前付けがあって、これを台集合に忘却する。
  - $(H^n (X; \mathbb{Z} / 2))_{\text{set}}$ という集合、 $(H^n (X; \mathbb{Z} / 2))_{\text{ab}}$ という群構造 ... に対して、
    $H^n (X; \mathbb{Z} / 2)$ という書き方は許されず、集合が入るところに群が来たら集合に忘却する。

他の案でいいのか思いつかなかったので、両方を混ぜて、構造への名前つけと、集合と構造の結び付けの宣言を行う方式にする。

$H^n (X; \mathbb{Z} / 2)$ は集合と考え、 $H^n (X; \mathbb{Z} / 2)_{\text{ab}}$ という群構造を別に宣言する。
$\text{Group structure for } H^n (X; \mathbb{Z} / 2) := H^n (X; \mathbb{Z} / 2)_{\text{ab}}$ という宣言があると、
以降は $H^n (X; \mathbb{Z} / 2)$ が群構造が来るべきところに書かれていたら、 $H^n(X; \mathbb{Z} / 2)_{\text{ab}}$ を
（**検証器が**宣言をもとに）選び出して代入する。

## 演算子とオーバーロード
一般の群についての議論をする場合に $*$ という記号を使う場合と、単に自然数の積をもって $*$ を使う場面がある。
同じ記号を使っているが、文脈によって適切に解釈してほしい。
また、 $a * b$ は $a \in X$ となる $X$ を**考えずに**一意に定まってほしい気持ちがある。
（これは coference が成り立つみたいな話？）
型付けが一意な状況ならともかく、文脈をもとに $a$ が何であるかのみによって規定されていてほしいと思う。

# ちょっと考えが及ばないところ
今は対処が難しいので、書くだけ書いておく。

## 同型の計算
幾何の代数不変量だと、あまり同型を気にしないことがあり、同型の取り方を後から議論しても間に合うことも多い。
なので、「どのように同型か」という情報は忘れて「同型である」だけを気にするような書き方が多い。

> $H_1(M; \mathbb{Z}) = \mathbb{Z}$

のような書き方とか。
「どのように同型か」は構造だけど、「同型である」は性質なので、
同型であることだけをもとに定義を組み立てるのは、 well-definedness を議論する必要があったりする。

線形空間の例：
$V \cong \mathbb{R}^n$ がわかっていたとして $V \overset{f}{\to} V$ のトレースの定義を
「同型 $\phi$: $V \to \mathbb{R}^n$ を用いて $\text{tr} \phi \circ f \circ (\phi^{-1})$ とする。」
は、 well-definedness の議論が必要になる。

## $=$ の両辺を必要に応じて制限する
微分形式についての主張だと、
座標をとって行列が出てくるような話の場合には、
$\omega = \omega _1 \wedge \omega _2$ みたいなものは、
それぞれの定義域を好きなだけ狭めての議論になる。

# ほしいプログラミングとしての機能
## 名前空間を分ける
module についての扱いをどうするか。
1. module の中で宣言されている変数に代入ができないといけない。
2. module は入れ子にできないと、コードを書くのが難しい。

## マクロや notation について
ユーザーがトークンの列を処理することができるといい。
例えば、
```
reasoning!{
  P1 & h1
  ==> P2 & h2
  ==> P3 & h3
}
```
は Prop `P1` から Prop `P3` をどう導出すればいいか記述しているが、
これを `((h3: P2 -> P3) (h2: P1 -> P2) (h1: P1)): P3` に変形するマクロが、**ユーザーにも**書けるとうれしい。
このマクロを記述する言語はできれば、外部のツールとしてではなく、内部の言語として書かれていたほうが、
インターネットでは保存がきく。

# 検証器の仕様について
部分集合がある時点で、項と型を与えられても導出木が全部導出できるわけではない。
ただ、導出木を書かせるのも意味がないので、
できる限り導出木の雰囲気に近いアルゴリズムと検査器に読ませる形式文法を考えないといけない。

- 導出木の展開を考えるうえで、同じ証明を作らないといけなくなるとつらい。
  - 例えばふつうに実装したら、
    $\text{id} = \lambda X: *^s, \lambda x: X, x: (X: *^s) \to X \to X$ に対して、
    $A: *^s, a: A \vdash \text{id} \{A \mid \top\} (\text{id} \{A \mid \top\} a)$ の検査時に $2$ 回 $\top$ を証明する必要が出てくるようになってしまう。
  - また、 $A: *^s, B: \Power(A), x: \Ty(B)$ とわかっているのに、 $ \vdash x: \Ty(B)$ の導出木を $\vdash x: A$ からやって $\vDash \Pred(A, B, x)$ を要求するようなら、
    とってもめんどくさい。
  - DAG を作るほうがいい。 up alpha conversion を無視したほうがいいので、この点でも locally nameless が楽になる。
- 検証器は展開時に木構造じゃなくて DAG で judgement の関係を保持する。
- provability の場合には、 $\beta$ modulo を加味して保持する。
  - すでにあるかどうかを検査する？...normalize すると停止しなくなるので、 Prop かどうかを検査すること。
- $\vDash P$ の導出に何を使うかがユーザーに指定できないといけない。
  - 証明が要求される部分で適宜ユーザーが証明を与えるための文法が必要。

# 実装側の話
- 内部での表現は locally nameless にしておく。
  - theory-local definition と theory を覚えておく必要がある。
  - 束縛変数の名前と、束縛される部分を覚えておく。
    - subset やら exist やらも含めて。
    - ind-elim のところも vec で引数をとっておく。
