# code での文法の検討
- checker 用の命令は `#` で始まる
  - `#include` ... 他の読むべきファイルを連結する（ファイルの頭に）
  - `#eval` ... normalize する
- `theory` の連結に意味論を与えたい。
- 基本的には、パースの際に空白で区切ったものが token になるようにする。
- ユーザーが処理するように自由に使える token と、言語側で予約している token をわける。
  - `'name` と `'variable` は identifier にする。
    - 気持ち的には、 `'name` は展開されないやつで、 `'variable` は展開されるやつ。
  - `'number` はそのまま数字のこと
  - `'macro` は `'name` の後に空白無しで `!` とする。
    - 例： `reasoning!`, `either!`
  - `'macro-acceptable` は token 側とかぶらないようなやつのこと。 
    - 例： `"mod"`, `+++`, `!hello` は acceptable
    - ダメな例： `:` は記法がかぶるのでダメ。
- 記号の解釈を選ぶ必要があるような部分を明示的に書くための文法として `$(` から `$)` で囲むことができるようにする。
  - context を選ぶ場合には、 `$ ... )` の間に何か書く。
- 帰納型は引数を `(` と `)` で囲んで明示的に与える方式にしたい（見やすいから）。
- なるべく機械と目でのパースを楽にするため、目的ごとに記号を分ける。
- 数学的構造の話には Record 型"のようなもの"を使う。
  - 項は nominal にするために `RecordName { fiele := expression}` とする。
  - 一般の Record 型が混ざると話がややこしい（帰納型で十分に記述できる）ので、数学的構造を扱うことを念頭に考える。
  - 構造の性質については、構造に含めずに、 subset を記述しやすくするものと考えて、形容詞みたいに扱えるようにしたい。
- 使うかもしれない記法のメモ
  - `a@b`

# 構文（案）
- `'theory-decl` = `"theory" 'name "(" ('parameter-decl)* ")" ("requires" ('name)+)* "{" ('code-decl)+ "}"`
- `'parameter-decl` = `'variable ":" 'expression`
- `'code-decl` = either
  - `"definition" 'variable ":" 'expression ":=" 'code-body ('where)? ";"`
  - `"theorem" 'variable ":" 'expression ":=" 'code-body ('where)? ";"`
  - `"interpretation" "$(" ('expression | 'macro-acceptable)+ "$)" ":=" 'expression ";"`
  - `"inductive"` ... 帰納型の定義
  - `"structure"` ... 構造の定義
- `'code-body` = either
  - `'expression`
  - `"{" ('block-decl)* 'expression "}"`
  - `'macro "{" ('expression | 'macro-acceptable)+ "}"`
- `'block-decl` =  either 
  - `"fix" ('variable ":" 'expression)+ ";"`
  - `"take 'variable ":" 'expression "|" 'variable ":" 'expression ";"`
  - `"have" 'variable ":" 'expression ":=" 'code-body`
  - `"sufficient" 'expression "by" 'expression;`
- `'where` = `"where" "{" ("-" 'variable ":" 'expression ":=" 'expression ";")+ "}"`
- `'expression` = either
  - math macro: `"$" "(" ('expression | 'macro-acceptable)+ "$" ")"`
  - module.access: `'name ("." 'name)+`
  - paren: `'parend-exp` ... `"(" 'expression ")"` のこと。
  - pipe: `'expression | 'expression` ... `x | f` は `f(x)` に自動的に修正されるとする。
  - sort: `("\PROP" | "\SET" ("(" 'number ")")? | "\TYPE" )`
  - variable: `'variable`
  - depprod.form: `"(" 'variable ":" 'expression ")" "->"  'expression`
  - depprod.intro: `"(" 'variable ":" 'expression ")" "=>"  'expression`
  - depprod.elim: `'expression 'expression`
  - ind.form: `'name "(" ('expression ",")* ")"`
  - ind.intro: `'name "::" 'name "(" ('expression ",")* ")"`
  - ind.elim: `"elim" "(" 'name ")" 'expression "return" 'expression "with" ( "|" 'name "(" ('variable ",") ")" "="> 'expression )* "end"`
  - record.form ``'name "(" ('expression ",")* ")"``
  - record.intro: `'name "(" ('expression ",")* ")" "{" "}"`
  - record.proj: `'expression "#" 'name`
  - proof.term: `\Proof 'expression`
  - power.set: `'\Power 'expression`
  - sub.set: `"{" 'variable ":" 'expression "|" 'expression "}"`
  - predicate: `\Pred "(" 'expression "," 'expression "," 'expression ")"`
  - identity: `'expression "=" 'expression`
  - exists: `\non-empty 'expression`
  - take: `\take 'variable ":" 'expression "," 'expression`
  - abort: `\abort`
