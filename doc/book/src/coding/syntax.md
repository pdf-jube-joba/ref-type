# code での文法の検討
- checker 用の命令は `#` で始まる
  - `#include` ... 他の読むべきファイルを連結する（ファイルの頭に）
  - `#eval` ... normalize する
- `theory` の連結に意味論を与えたい。
  - 基本的には、パースの際は空白で区切ったものが token になるようにする。
  - `'name` と `'variable` は identifier にする
  - `'number` はそのまま数字のこと
  - `'macro` は `'name` の後に空白無しで `!` とする。
  - `'macro-acceptable-token` は token 側とかぶらないようなやつのこと。 
    - 例えば、 `"mod"` や `+++` は acceptable だが、 `:` は記法がかぶるのでダメ。
- keyword のようなものをなるべく登場させたくない。
  - expression の中で何を variable として使ってよいかの自由度を高めたい。
- syntax は
  - `'theory-decl` = `"theory" 'name "(" ('parameter-decl)* ")" ("requires" ('name)+)* "{" ('code-decl)+ "}"`
  - `'parameter-decl` = `"var" 'variable ":" 'expression` | `"law" 'variable ":" 'expression`
  - `'code-decl` = either
    - `"definition" 'variable ":" 'expression ":=" 'code-body`
    - `"theorem" 'variable ":" 'expression ":=" 'code-body`
  - `'code-body` = either
    - `'expression;`
    - `"{" ('block)* 'expression "}"`
    - `'macro "{" ('expression | 'macro-acceptable)+ "}"`
  - `'block` =  either 
    - `"fix" 'variable ":" 'expression ";"`
    - `"take 'variable ":" 'expression "|" 'variable ":" 'expression ";"`
    - `"notice" ('expression) "is" ('expression);` // これはコメント用と思っていい。
    - `"have" 'variable ":" 'expression ":=" 'code-body`
    - `"sufficient" 'expression "by" 'expression;`
  - `'where` = `"where" "{" ("-" 'variable ":" 'expression = 'expression ";") "}"`
  - `'expression` = either
    - math macro: `"$" ('expression | 'macro-acceptable)+ "$"`
    - module.access `'name "." 'name`
    - paren: `'parend-exp`
    - sort: `("\PROP" | "\SET" ("(" 'number ")")? | "\TYPE" )`
    - variable: `'variable`
    - depprod.form: `"(" 'variable ":" 'expression ")" "->"  'expression`
    - depprod.intro: `"(" 'variable ":" 'expression ")" "=>"  'expression`
    - depprod.elim: `'expression 'expression`
    - ind.form: `'name "(" ('expression ",")* ")"`
    - ind.intro: `'name "::" 'name "(" ('expression ",")* ")"`
    - ind.elim: `"elim" "(" 'name ")" 'expression "return" 'expression "with" ( "|" 'name "(" ('variable ",") ")" "="> 'expression )* "end"`
    - record.form ``'name "(" ('expression ",")* ")"``
    - record.intro: `'name "(" ('expression ",")* ")" "{" "}"`
    - record.proj: `'expression "#" 'name`
    - proof term: `\Proof 'expression`
    - power.set: `'\Power 'expression`
    - sub.set: `"{" 'variable ":" 'expression "|" 'expression "}"`
    - predicate: `\Pred "(" 'expression "," 'expression "," 'expression ")"`
    - identity: `'expression "=" 'expression`
    - exists1: `\non-empty 'expression`
    - take: `\take 'variable ":" 'expression "," 'expression`
  - `'parend-exp` = `"(" 'expression ")"`

- 使うかもしれない記法のメモ
  - `a@b`

# 実装での話
- なるべく機械と目でのパースを楽にするため、目的ごとに記号を分ける。
- 内部での表現は locally nameless にしておく。
  - theory-local definition と theory を覚えておく必要がある。
  - 束縛変数の名前と、束縛される部分を覚えておく。
    - subset やら exist やらも含めて。
    - ind-elim のところも vec で引数をとっておく。
- sum ではなく レコード型を入れて、多相にしない。
- trait と impl： coference は一回置いておく。
  - trait は課す側・ impl は証明する側
  - impl の中で証明するのはめんどくさいが、証明用の書き方を置いておく？
  - impl のときに証明したものは（当然）既知のものとする。
- 帰納型は引数を explicit に与える方式にしたい（見やすいから）。
  - explicit というか、 `(` と `)` で囲みたい。
