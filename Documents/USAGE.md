# Core について
Core を起動すると対話的にコマンドを打つことができるようになる。
コマンドで Judgement の導出木を成長させていく。
とりあえず例をいくつか出す。

# 始め方とやめ方。

- RefType.Core/ で dotnet run などすると動く（バイナリは配布しないと思う）。
- vscode なら F5 とかでも動いた（当たり前なのか？）

などすると、コンソールで Core が起動し次のメッセージが出てきて、
`>` のところに入力を求められるはず。

```
!Welcome
>
```

ここで `#quit` とうつと終了する。

```
>#quit
```

知らないコマンドが出てくると unknown action と出てくる。
以降、出力と入力を同時に書く。
`>` のついているところが入力。

# 例１
## コンテキストを用意してみる。
空のコンテキストの木をつくろう。
コンテキストが一つ、項が二つ、木が一つメモリー（電卓のやつみたいな）に入っていて、
それをコマンドで操作する。
まずは `#prove-context-well` と打てば、何もいじっていないコンテキスト（空）を示すモードに入る。

```
!Welcome
>#prove-context-well
goal is setted
```

`#prove-context-well` で現在のメモリーにあるコンテキストの well-defined 性の証明を始める。
これによって木のメモリーに導出の完成されていない木が入る。
`#show-tree` で木全体が見れる。

```
>#show-tree
*[-]|-end
```

`*` は木の最後を表し `[-]` はまだ証明されていないことを表している。
うしろの例２か３を見たほうがここで言っていることはわかりやすいかも。
`#show-goal` で証明できていないこと全体を見れる。

```
>#show-goal
|-end
```

`|-end` が空の木が現在証明すべきことにあることを示している。

## 実際に木を証明する。
空のコンテキストが well-defined なのは 型規則の ContextEmpty よりわかる。
`#break-empty` と打つ。
これは現在のゴールのうち一番上側にあるものを context empty で解決できないか試みる。

```
>#break-empty
success
```

成功したのでshow-goalとshow-treeをしてみる。

```
>#show-goal
there is no goal
>#show-tree
*[*]Rule:ContexEmpty||Prop:|-end
```

`*[*]` で以降の木は証明されていることを表している。
これ以上証明することはない。
exact で構成した木が正しいことを示す。

```
>#goal-exact
completed
```

構築完了。
空のコンテキストが導出できることが分かった。