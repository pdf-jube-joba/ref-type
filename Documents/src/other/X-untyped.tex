ラムダ項の定義としては
\begin{itembox}[l]{項の定義}
  \begin{grammar}
    <term ; t> ::= <variable ; x>
    \alt `Fun' <variable> <term>
    \alt `App' <term> <term>
  \end{grammar}
\end{itembox}

これについては型理論はない。
ラムダ項にどういうものが定義されていたかと言うと、

\begin{itemize}
  \item 自由変数、 FV := \texttt{項の中にある束縛されていない変数} を返す関数
  \item 単純な代入 (\(M\{x \leftarrow N\}\)) := \texttt{項 \(M\) の中に自由変数としてあらわれる変数 \(x\) を \(N\) に置き換える}
  \item \(\alpha\) 同値：項の間の関係 := 次で生成される同値関係
    \begin{itemize}
      \item \(\texttt{Fun} \, x \, M =_{\alpha} \texttt{Fun} \, y \, (M \{x \leftarrow y\})\) ただし \(M\) は自由変数に \(y\) をもたない。
    \end{itemize}
  \item 簡約、 \(\beta\) 変換：項の間の関係 := \texttt{なんかいい感じの奴}
  \item 評価戦略：上の \(\beta\) 変換なる関係を実際に表現する、項から項への関数
  \item 値、正規形：ある条件を満たすラムダ項
\end{itemize}

これらに対して合流性やらが成り立つのだった。
項の間の同値関係 \(t_1 \equiv t_2\) を次の規則から生成する。

\begin{itembox}[l]{ラムダ項の等式}
  \[\infer[\text{alpha}]{\texttt{Fun} \, x_1 \, t_1 \equiv \texttt{Fun} \, x_2 \, (t_1\{x_1 \leftarrow t_2\})}{x_2 \notin \text{FV}(t_2)}\]
  \[\infer[\text{computation}]{\texttt{App} \, (\texttt{Fun} \, x \, t_1) \, t_2 \equiv t_2\{x \leftarrow t_2\}}{x \notin \text{FV}(t_2)}\]
  \[\infer[\text{conversion-fun}]{\texttt{Fun} \, x \, t_1 \equiv \texttt{Fun} \, x \, t_2}{t_1 \equiv t_2}\]
  \[\infer[\text{conversion-app-1}]{\texttt{App} \, t_1 \, t_2 \equiv \texttt{App} \, t_3 \, t_2}{t_1 \equiv t_3}\]
  \[\infer[\text{conversion-app-2}]{\texttt{App} \, t_1 \, t_2 \equiv \texttt{App} \, t_1 \, t_3}{t_2 \equiv t_3}\]
\end{itembox}

\(\alpha , \beta\) 変換はこの同値と非常にうまくいくことが（定理としてであって定義ではなく）わかる。
注意として、
\begin{itemize}
  \item conversion-fun は関数型言語で作るときには人によっては使わないかも。スタックマシンへのコンパイルの場合は値としての関数は変に reduction せず写したり、 thunk と呼んで抽象化されたものはそれ以上変形しないことがある。
  \item \(\beta\) 変換は関係であって関数ではない、具体的に計算する方法を定めることが評価戦略を定めることにあたり、大体どの評価方法をつかっても同じものが返ってくる（いわゆる合流性）。
\end{itemize}
また、これに
\[\infer[\text{computation-eta}]{t \equiv \texttt{Fun} \, x \, (\texttt{App} \, t \, x)}{}\]
を付け加えることもあるが、外延的ラムダ計算という別の体系になる。