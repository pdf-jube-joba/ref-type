型付きラムダ計算をプログラムっぽく拡張する。
拡張の方向性はいろいろあり、自然数と真偽値だけ追加する場合でもゆれがある。
特に、 
\begin{itembox}[l]{項、型、コンテキストの定義}
\begin{grammar}
  <type ; T> ::= \ldots
  \alt `Nat'
  \alt `Bool'

  <term ; t> ::= \ldots
  \alt `O' | `S' <term>
  \alt `match' <term> `with' <term> `or' <variable> <term>
  \alt `true' | `false'
  \alt `if' <term> `then' <term> `else' <term>

  <context ; \(\Gamma\) > ::= empty | <context> ,  <term-variable> : <type>
\end{grammar}
\end{itembox}

\texttt{Nat} という型は帰納的に定義され、コンストラクタが \texttt{O} と \texttt{S} でコンストラクタの除去のための項が \texttt{ifzero} である。

\begin{itembox}[l]{型付け規則}
  \ldots
  \[\infer[\text{nat-intro-O}]{\vdash \texttt{O} : \texttt{Nat}}{}\]
  \[\infer[\text{nat-intro-S}]{\Gamma \vdash \texttt{S} \, M : \texttt{Nat}}{\Gamma \vdash M : \texttt{Nat}}\]
  \[\infer[\text{nat-intro-}]{}{}\]
\end{itembox}

ラムダ項の間の等式や簡約は大体型を無視した感じで定義されるため、型付けとは別に定義することができる。
後でこの二つが強く関係してくるような体系がでてくる（定義時にお互いに依存するなど）
型理論で成り立つかどうかを調べるのはだいたい以下のような感じ。
有限ステップで停止する形で判定できることを決定できると表現する（あまりよくない表現で申し訳ない）。

\begin{itemize}
  \item \(\Gamma \vdash t : A\) であることの証明を与えられたとき、正しいか決定できる。
  \item \(\Gamma \vdash t : A\) であるかどうか決定できる...type check decidability
  \item \(\Gamma\) と \(t\) に対して \(\Gamma \vdash t : A\) なる \(A\) が存在するか決定できる...type inference
  \item \(\Gamma\) と \(A\) に対して \(\Gamma \vdash t : A\) なる \(t\) が存在するか計算できる...type inhabitants
  \item \(\Gamma \vdash t : A\) かつ \(\Gamma \vdash t : B\) なら \(A = B\) である...type uniqueness
  \item \(\Gamma \vdash t : A\) かつ \(t \rightarrow_{\beta} t^{\prime}\) なら \(\Gamma \vdash t^{\prime} : A\)...subject reduction
  \item \(\vdash t : A\) なら \(t\) の簡約が停止し値になる
\end{itemize}