<!doctype html>
<meta charset="utf-8">
<style>
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: #f6f7fb;
    color: #111;
  }

  .container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    height: 100vh;
  }

  textarea {
    margin: 0;
    padding: 1em;
    font-size: 1rem;
    border: none;
    outline: none;
    height: 100%;
    box-sizing: border-box;
    resize: none;
    border-right: 1px solid #ddd;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Segoe UI Mono", monospace;
  }

  /* interactive tree area */
  .output {
    padding: 1em;
    height: 100%;
    overflow: auto;
    box-sizing: border-box;
  }

  .logs {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .message {
    background: #fff;
    border-radius: 6px;
    padding: 0.75rem 1rem;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.03);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    white-space: pre-wrap;
  }

  details {
    background: #fff;
    border-radius: 6px;
    padding: 0.25rem 0.5rem;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.03);
  }

  summary {
    cursor: pointer;
    list-style: none;
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  summary:hover {
    background: rgba(0, 0, 0, 0.02);
  }

  .head-text {
    flex: 1;
  }

  .badge {
    font-size: 0.75rem;
    padding: 0.15rem 0.5rem;
    border-radius: 999px;
  }

  .success .badge {
    background: #e6ffed;
    color: #006a2e;
  }

  .error .badge {
    background: #ffecec;
    color: #7a0710;
  }

  .pending .badge {
    background: #fff5d6;
    color: #7a5b00;
  }

  .error-propagate .badge {
    background: #ffecec;
    color: #7a0710;
  }

  .error-cause .badge {
    background: #f8d7da;
    color: #721c24;
  }

  .child-list {
    padding-left: 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .error-banner {
    background: #ffecec;
    color: #7a0710;
    border: 1px solid #f5c2c2;
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    margin-bottom: 0.5rem;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;
    white-space: pre-wrap;
  }

  @media (max-width: 700px) {
    .container {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
    }

    textarea {
      border-right: none;
      border-bottom: 1px solid #ddd;
    }
  }
</style>

<div class="container">
  <textarea id="input">\module Example {}</textarea>
  <div class="output">
    <div id="error-banner" class="error-banner" style="display:none"></div>
    <div id="output" class="logs"></div>
  </div>
</div>

<script>
  const input = document.getElementById("input");
  const output = document.getElementById("output");

  // --- 可調整パラメータ ---
  let baseDelay = 150;   // 最短デバウンス(ms)
  let maxDelay = 1200;  // 最長デバウンス(ms)
  let deltaChars = 4;     // 前回送信からの最低変更文字数
  let maxWait = 1200;  // どれだけ入力が続いても、この時間で強制送信(ms)

  // --- 内部状態 ---
  let composing = false;       // IME 変換中フラグ
  let lastSentText = input.value;
  let lastSentAt = performance.now();
  let timer = 0;
  let inFlight = null;         // { controller, startedAt }
  let pendingText = null;      // 「最後勝ち」用の最新テキスト
  let rttAvg = 200;            // RTT 移動平均

  function computeDelay() {
    const visBoost = document.visibilityState === "visible" ? 1 : 2.0;
    const lenBoost = 1 + Math.min(2, input.value.length / 2000);
    const rttBoost = Math.min(3, Math.max(0.8, rttAvg / 200));
    return Math.min(maxDelay, Math.round(baseDelay * visBoost * lenBoost * rttBoost));
  }

  function shouldSend(now, text) {
    const delta = Math.abs(text.length - lastSentText.length);
    const waited = now - lastSentAt;
    return (delta >= deltaChars) || (waited >= maxWait);
  }

  function scheduleSend() {
    clearTimeout(timer);
    if (composing) return; // IME変換中は送らない
    const now = performance.now();
    const text = input.value;
    if (!shouldSend(now, text)) {
      // 変更が小さければまだ待つ
      timer = setTimeout(scheduleSend, computeDelay());
      return;
    }
    const delay = computeDelay();
    timer = setTimeout(() => sendLatest(), delay);
    pendingText = text; // 最新を記録（あとで「最後勝ち」で送る）
  }

  async function sendLatest() {
    const text = input.value; // 直前で上書きされてたら、常に最新を使う
    pendingText = null;

    // 既存リクエストがあればキャンセル
    if (inFlight) inFlight.controller.abort();
    const controller = new AbortController();
    inFlight = { controller, startedAt: performance.now() };

    try {
      const res = await fetch("/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text }),
        signal: controller.signal,
      });
      const t1 = performance.now();
      rttAvg = (rttAvg * 0.7) + ((t1 - inFlight.startedAt) * 0.3); // RTT移動平均
      inFlight = null;

      const data = await res.json();
      hideErrorBanner();
      renderLogs(data.result || []);
      lastSentText = text;
      lastSentAt = t1;

      // 送信中に更に入力が進んだ場合は、終わった直後に最新をもう一度評価
      if (pendingText !== null) scheduleSend();
    } catch (e) {
      inFlight = null;
      if (e.name === "AbortError") {
        // request aborted by newer input; ignore
        return;
      }
      showErrorBanner('Network or server error: ' + String(e));
    }
  }

  function showErrorBanner(msg) {
    const b = document.getElementById('error-banner');
    if (!b) return;
    b.textContent = msg;
    b.style.display = 'block';
  }

  function hideErrorBanner() {
    const b = document.getElementById('error-banner');
    if (!b) return;
    b.style.display = 'none';
    b.textContent = '';
  }

  // render helpers
  function nodeTextAndClass(nodeObj) {
    // nodeObj is externally tagged enum like { "Success": "..." }
    if (nodeObj == null) return { text: "", cls: "pending" };
    if (typeof nodeObj === 'string') return { text: nodeObj, cls: 'pending' };
    if (typeof nodeObj === 'object') {
      const keys = Object.keys(nodeObj);
      if (keys.length === 0) return { text: JSON.stringify(nodeObj), cls: 'pending' };
      const k = keys[0];
      const v = nodeObj[k];
      let cls = k.toLowerCase();
      if (cls === "errorpropagate") cls = "error-propagate";
      if (cls === "errorcause") cls = "error-cause";
      return { text: v, cls };
    }
    return { text: String(nodeObj), cls: 'pending' };
  }

  function renderTreeNode(tree) {
    // tree: { head: Node, children: [tree...] }
    const { head, children } = tree;
    const info = nodeTextAndClass(head);

    const details = document.createElement('details');
    details.classList.add(info.cls);

    const summary = document.createElement('summary');
    const badge = document.createElement('span');
    badge.className = 'badge';
    badge.textContent = info.cls.toUpperCase();

    const headText = document.createElement('span');
    headText.className = 'head-text';
    headText.textContent = info.text;

    summary.appendChild(badge);
    summary.appendChild(headText);
    details.appendChild(summary);

    if (children && children.length > 0) {
      const childWrap = document.createElement('div');
      childWrap.className = 'child-list';
      for (const c of children) {
        childWrap.appendChild(renderTreeNode(c));
      }
      details.appendChild(childWrap);
    }

    return details;
  }

  function renderLogs(logs) {
    output.innerHTML = '';
    if (!Array.isArray(logs)) return;
    for (const entry of logs) {
      if (entry.Derivation) {
        // older representation: { Derivation: Tree }
        const tree = entry.Derivation;
        const node = renderTreeNode(tree);
        output.appendChild(node);
      } else if (entry.Derivation !== undefined) {
        // fallback
        const node = renderTreeNode(entry.Derivation);
        output.appendChild(node);
      } else if (entry.Message || entry.message) {
        const msg = entry.Message || entry.message;
        const div = document.createElement('div');
        div.className = 'message';
        div.textContent = msg;
        output.appendChild(div);
      } else if (entry.Log && entry.Log.Derivation) {
        // defensive
        const node = renderTreeNode(entry.Log.Derivation);
        output.appendChild(node);
      } else {
        // new format: either { "Derivation": { head: ..., children: [...] } } or { "Message": "..." } or direct objects
        if (entry.head && entry.children) {
          output.appendChild(renderTreeNode(entry));
        } else if (entry.head) {
          output.appendChild(renderTreeNode(entry));
        } else {
          const div = document.createElement('div');
          div.className = 'message';
          div.textContent = JSON.stringify(entry, null, 2);
          output.appendChild(div);
        }
      }
    }
  }

  // bind events
  input.addEventListener("input", scheduleSend);
  input.addEventListener("compositionstart", () => { composing = true; });
  input.addEventListener("compositionend", () => { composing = false; scheduleSend(); });
  document.addEventListener("visibilitychange", () => { if (document.visibilityState === "visible") scheduleSend(); });

  // initial
  scheduleSend();
</script>