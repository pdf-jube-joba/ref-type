use crate::syntax::{Identifier, MacroToken};
use super::{AtomTok, AtomLike, SExpTok, MacroSeq, ModItemDecl, ModDecl};
use crate::utils::assoc_apply_vec;
use either::Either;
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub SortAst: kernel::exp::Sort = {
  "\\Prop" => kernel::exp::Sort::Prop,
  "\\PropKind" => kernel::exp::Sort::PropKind,
  "\\Set" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
  "\\SetKind" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
}

Ident: Identifier = {
  <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => Identifier(String::from(s)),
}

num: usize = {
  <s:r"[0-9]+"> => usize::from_str(s).unwrap(),
}

MacTok: MacroToken = {
  <n: num> => MacroToken(n.to_string()),
  <s:r"[#$%]+"> => MacroToken(String::from(s)),
}

pub AtomTokAst: AtomTok = {
  <s: SortAst> => AtomTok::Sort(s),
  <v0: Ident> => AtomTok::AccessPath(vec![v0]),
  <v0: Ident> "." <v1: Ident> => AtomTok::AccessPath(vec![v0, v1]),
  <v0: Ident> "." <v1: Ident> "." <v2: Ident> => AtomTok::AccessPath(vec![v0, v1, v2]),
}

pub AtomLikeAst: AtomLike = {
  <a: AtomTokAst> => AtomLike::AtomTok(a),
  "(" <e: SExpTokAst+> ")" => AtomLike::ParenToks(e),
  "{" <e: SExpTokAst+> "}" => AtomLike::CurlyToks(e),
  "$(" <seq: MacAst+> "$)"  => AtomLike::MathMacro(seq),
  "!" <nameast: Ident> "{" <seq: MacAst+> "}" => AtomLike::NamedMacro(nameast, seq),
}

MacAst: MacroSeq = {
  <a: AtomTokAst> => MacroSeq::AtomLike(AtomLike::AtomTok(a)),
  <tok: MacTok> => MacroSeq::MacTok(tok),
  "(" <e: MacAst+> ")" => MacroSeq::Seq(e),
}

SExpTokAst: SExpTok = {
  <a: AtomLikeAst> => SExpTok::AtomLike(a),
  "=>" => SExpTok::LambdaArrow,
  "->" => SExpTok::ProductTypeArrow,
  ":" => SExpTok::Colon,
  "|" => SExpTok::Mid,
}

pub SExpAll: Vec<SExpTok> = {
  <v: SExpTokAst+> => v,
}

ModItemAst: ModItemDecl = {
  IndSpecsDecl,
  DefDecl,
  ImportDecl,
}

BindParend: (Identifier, Vec<SExpTok>) = {
  "(" <v: Ident> ":" <ty: SExpTokAst+> ")" => (v, ty)
}

IndSpecsDecl: ModItemDecl = {
  "inductive" <typename: Ident> <ps: BindParend*> ":" <ar: SExpAll> ":=" <ctors: Ctor+> => ModItemDecl::Inductive {
    type_name: typename,
    parameter: ps,
    arity: ar,
    constructors: ctors,
  }
}

Ctor: (Identifier, Vec<SExpTok>) = {
  "|" <n: Ident> ":" <e: SExpAll> ";" => (n, e)
}

DefDecl: ModItemDecl = {
  "definition" <n: Ident> ":" <tyast: SExpAll> ":=" <bdast: SExpAll> ";" => ModItemDecl::Definition {
    name: n,
    ty: tyast,
    body: bdast,
  }
}

BindSubst: (Identifier, Vec<SExpTok>) = {
  <v: Ident> ":=" <e: SExpAll> ";" => (v, e),
}

ImportDecl: ModItemDecl = {
  "import" <mname: Ident> "(" <bst: BindSubst*> ")" "as" <v:Ident> => {
    ModItemDecl::Import {
      module_name: mname,
      path: bst,
      import_name: v,
    }
  }
}

SimpleBindSemicolon: (Identifier, Vec<SExpTok>) = {
  <v: Ident> ":" <e:SExpAll> ";" => (v, e)
}

ModuleRep: ModDecl = {
  "module" <nameast: Ident> "{" <decls: ModItemAst*> "}" => ModDecl { name: nameast, parameters: vec![], declarations: decls },
  "module" <nameast: Ident> "(" <sb: SimpleBindSemicolon+> ")" "{" <decls: ModItemAst*> "}" => ModDecl { name: nameast, parameters: sb, declarations: decls },
}

pub ModuleAll: Vec<ModDecl> = {
  ModuleRep*
}
