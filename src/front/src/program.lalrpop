use crate::syntax::{Identifier, SExp, MacroToken, Bind, Module, ModuleItem, MacroExp};
use either::Either;
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub SortAst: kernel::exp::Sort = {
  "\\Prop" => kernel::exp::Sort::Prop,
  "\\PropKind" => kernel::exp::Sort::PropKind,
  "\\Set" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
  "\\SetKind" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
}

Ident: Identifier = {
  <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => Identifier(String::from(s)),
}

num: usize = {
  <s:r"[0-9]+"> => usize::from_str(s).unwrap(),
}

MacTok: MacroToken = {
  <n: num> => MacroToken(n.to_string()),
  <s:r"[#$%;]+"> => MacroToken(String::from(s)),
}

pub SExpAll = {
  ArrowSeparated,
}

ArrowSeparated: SExp = {
  <bdast: Binder> "->" <bodyast: ArrowSeparated> => SExp::Prod { bind: bdast, body: Box::new(bodyast)},
  <bdast: Binder> "=>" <bodyast: ArrowSeparated> => SExp::Lam { bind: bdast, body: Box::new(bodyast)},
  Combined,
}

Combined: SExp = {
  <funcast: AtomParen> <argast: Combined> => SExp::App { func: Box::new(funcast), arg: Box::new(argast), piped: false },
  <argast: AtomParen> "|" <funcast: Combined> => SExp::App { func: Box::new(funcast), arg: Box::new(argast), piped: true },
  AtomParen,
}

AtomParen: SExp = {
  Atom,
  "(" <e: SExpAll> ")" => e,
  "$(" <seq: MacAst+> "$)"  => SExp::MathMacro { tokens: Box::new(MacroExp::Seq(seq)) },
  "!" <nameast: Ident> "{" <seq: MacAst+> "}" => SExp::NamedMacro { name: nameast, tokens: Box::new(MacroExp::Seq(seq)) },
}

Atom: SExp = {
  <s: SortAst> => SExp::Sort(s),
  <v: Ident> => SExp::Identifier(v),
}

Binder: Bind = {
  "(" <v: Ident> ":" <e: SExpAll> ")" => Bind { var: Some(v), ty: Box::new(e), predicate: None },
  <e: Combined> => Bind { var: None, ty: Box::new(e), predicate: None },
}

MacAst: MacroExp = {
  "(" <e: SExpAll> ")" => MacroExp::Exp(e),
  <a: Atom> => MacroExp::Exp(a),
  <tok: MacTok> => MacroExp::Tok(tok),
}

SimpleBind: (Identifier, SExp) = {
  "(" <v: Ident> ":" <e:SExpAll> ")" => (v, e)
}

IndSpecsDecl: ModuleItem = {
  "inductive" <typename: Ident> <ps: SimpleBind+> ":" <ar: SExpAll> ":=" <ctors: Ctor*> => ModuleItem::Inductive {
    type_name: typename,
    parameter: ps,
    arity: Box::new(ar),
    constructors: ctors,
  }
}

Ctor: (Identifier, SExp) = {
  "|" <n: Ident> ":" <e: ArrowSeparated> ";" => (n, e)
}

DefDecl: ModuleItem = {
  "definition" <n: Ident> ":" <tyast: SExpAll> ":=" <bdast: SExpAll> ";" => ModuleItem::Definition {
    var: n,
    ty: tyast,
    body: bdast,
  }
}

ModItem: ModuleItem = {
  IndSpecsDecl,
  DefDecl,
}

SimpleBindSemicolon: (Identifier, SExp) = {
  <v: Ident> ":" <e:ArrowSeparated> ";" => (v, e)
}

ModuleRep: Module = {
  "module" <nameast: Ident> "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: vec![], declarations: decls },
  "module" <nameast: Ident> "(" <sb: SimpleBindSemicolon+> ")" "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: sb, declarations: decls },
}

pub ModuleReps: Vec<Module> = {
  ModuleRep*
}
