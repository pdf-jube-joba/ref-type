use crate::syntax::{Identifier, MacroToken, SExp, Bind, MacroExp};
use crate::utils::assoc_apply_vec;
use either::Either;
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub SortAst: kernel::exp::Sort = {
  "\\Prop" => kernel::exp::Sort::Prop,
  "\\PropKind" => kernel::exp::Sort::PropKind,
  "\\Set" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
  "\\SetKind" "(" <n: num> ")" => kernel::exp::Sort::SetKind(n),
}

Ident: Identifier = {
  <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => Identifier(String::from(s)),
}

num: usize = {
  <s:r"[0-9]+"> => usize::from_str(s).unwrap(),
}

MacTok: MacroToken = {
  <n: num> => MacroToken(n.to_string()),
  <s:r"[#]+"> => MacroToken(String::from(s)),
}

SExpPrimAtomAst: SExp = {
  <s: SortAst> => SExp::Sort(s),
  <v0: Ident> => SExp::AccessPath(vec![v0]),
  <v0: Ident> "." <v1: Ident> => SExp::AccessPath(vec![v0, v1]),
  <v0: Ident> "." <v1: Ident> "." <v2: Ident> => SExp::AccessPath(vec![v0, v1, v2]),
}

SExpAtomLike: SExp = {
  "(" <a: SExpAtomLike> ")" => a,
  "$(" <seq: MacAst+> "$)" => SExp::MathMacro { tokens: seq },
  "!" <nameast: Ident> "{" <seq: MacAst+> "}" => SExp::NamedMacro { name: nameast, tokens: seq },
  SExpPrimAtomAst,
}

pub SExpAst: SExp = {
  ArrowSeparated,
}

ArrowSeparated: SExp = {
  <bd: BindAst> "->" <bod: ArrowSeparated> => SExp::Prod { bind: bd, body: Box::new(bod) },
  <cb: Combined> "->" <bod: ArrowSeparated> => SExp::Prod { bind: Bind::Anonymous { ty: Box::new(cb)}, body: Box::new(bod) },
  Combined,
}

BindAst: Bind = {
  "(" <t: TypeAnnot> ")" => Bind::Named { var: t.0, ty: Box::new(t.1) },
  "(" "(" <t: TypeAnnot> ")" "|" <e: SExpAll> ")" => Bind::Named { var: t.0, ty: Box::new(t.1) },
  "(" "(" <t: TypeAnnot> ")" "|"  <p: Ident> ":" <e: SExpAll> ")" => Bind::Named { var: t.0, ty: Box::new(t.1) },
}

Combined: SExp = {
  <cb1: Combined> "|" <cb2: Combined> => Exp::App { func: cb2, arg: cb1, piped: false},
  <cb: Combined> <at: AtomLike> => Exp::App { func: cb, arg: at, piped: false},
  SExpAtomLike,
}

TypeAnnot: (Identifier, SExp) = {
  <v: Ident> ":" <a: SExpAtomLike> => (v, a),
}

MacAst: MacroExp = {
  <a: SExpAtomLike> => MacroExp::Exp(a),
  <tok: MacTok> => MacroExp::Tok(tok),
  "(" <e: MacAst+> ")" => MacroExp::Seq(e),
}

/*

IndSpecsDecl: ModItemDecl = {
  "inductive" <typename: Ident> <ps: BindParend*> ":" <ar: SExpAll> ":=" <ctors: Ctor+> => ModItemDecl::Inductive {
    type_name: typename,
    parameter: ps,
    arity: ar,
    constructors: ctors,
  }
}

Ctor: (Identifier, Vec<SExpTok>) = {
  "|" <n: Ident> ":" <e: SExpAll> ";" => (n, e)
}

DefDecl: ModItemDecl = {
  "definition" <n: Ident> ":" <tyast: SExpAll> ":=" <bdast: SExpAll> ";" => ModItemDecl::Definition {
    name: n,
    ty: tyast,
    body: bdast,
  }
}

BindSubst: (Identifier, Vec<SExpTok>) = {
  <v: Ident> ":=" <e: SExpAll> ";" => (v, e),
}

ImportDecl: ModItemDecl = {
  "import" <mname: Ident> "(" <bst: BindSubst*> ")" "as" <v:Ident> ";" => {
    ModItemDecl::Import {
      module_name: mname,
      path: bst,
      import_name: v,
    }
  }
}

SimpleBindSemicolon: (Identifier, Vec<SExpTok>) = {
  <v: Ident> ":" <e:SExpAll> ";" => (v, e)
}

ModuleRep: ModDecl = {
  "module" <nameast: Ident> "{" <decls: ModItemAst*> "}" => ModDecl { name: nameast, parameters: vec![], declarations: decls },
  "module" <nameast: Ident> "(" <sb: SimpleBindSemicolon+> ")" "{" <decls: ModItemAst*> "}" => ModDecl { name: nameast, parameters: sb, declarations: decls },
}

pub ModuleAll: Vec<ModDecl> = {
  ModuleRep*
}
*/