use crate::syntax::{Identifier, MacroToken};
use super::{AtomTok, AtomLike, SExpTok, MacroSeq};
use crate::utils::assoc_apply_vec;
use either::Either;
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub SortAst: kernel::exp::Sort = {
  "\\Prop" => kernel::exp::Sort::Prop,
  "\\PropKind" => kernel::exp::Sort::PropKind,
  "\\Set" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
  "\\SetKind" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
}

Ident: Identifier = {
  <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => Identifier(String::from(s)),
}

num: usize = {
  <s:r"[0-9]+"> => usize::from_str(s).unwrap(),
}

MacTok: MacroToken = {
  <n: num> => MacroToken(n.to_string()),
  <s:r"[#$%]+"> => MacroToken(String::from(s)),
}

AtomTokAst: AtomTok = {
  <s: SortAst> => AtomTok::Sort(s),
  <v0: Ident> => AtomTok::AccessPath(vec![v0]),
  <v0: Ident> "." <v1: Ident> => AtomTok::AccessPath(vec![v0, v1]),
  <v0: Ident> "." <v1: Ident> "." <v2: Ident> => AtomTok::AccessPath(vec![v0, v1, v2]),
}

AtomLikeAst: AtomLike = {
  <a: AtomTokAst> => AtomLike::AtomTok(a),
  "(" <e: SExpTokAst+> ")" => AtomLike::ParenToks(e),
  "{" <e: SExpTokAst+> "}" => AtomLike::CurlyToks(e),
  "$(" <seq: MacAst+> "$)"  => AtomLike::MathMacro(seq),
  "!" <nameast: Ident> "{" <seq: MacAst+> "}" => AtomLike::NamedMacro(nameast, seq),
}

MacAst: MacroSeq = {
  <a: AtomTokAst> => MacroSeq::AtomLike(a),
  <tok: MacTok> => MacroSeq::MacTok(tok),
  "(" <e: MacAst+> ")" => MacroSeq::Seq(e),
}

SExpTokAst: SExpTok = {
  <a: AtomLikeAst> => SExpTok::AtomLike(a),
}

pub SExpAll: Vec<SExpTok> = {
  <v: SExpTokAst+> => v,
}
/*

pub ArrowSeparated: SExp = {
  <bdast: Binder> "->" <bodyast: ArrowSeparated> => SExp::Prod { bind: bdast, body: Box::new(bodyast)},
  <bdast: Binder> "=>" <bodyast: ArrowSeparated> => SExp::Lam { bind: bdast, body: Box::new(bodyast)},
  <a: Atom+> => assoc_apply_vec(a),
  AtomParen,
}

Binder: Bind = {
  "(" <v: Ident> ":" <e: ArrowSeparated> ")" => Bind::Named { var: v, ty: Box::new(e) },
  "(" <v: Ident> ":" <e: ArrowSeparated> "|" <pre: ArrowSeparated> ")" => Bind::Subset { var: v, ty: Box::new(e), predicate: Box::new(pre) },
  "(" <v: Ident> ":" <e: ArrowSeparated> "|" <p: Ident> ":" <pre: ArrowSeparated> ")" => Bind::SubsetWithProof { var: v, ty: Box::new(e), predicate: Box::new(pre), proof: p },
  <e: Atom> => Bind::Anonymous { ty: Box::new(e) },
  <e: AtomParen> => Bind::Anonymous { ty: Box::new(e) },
}

SimpleBind: (Identifier, SExp) = {
  "(" <v: Ident> ":" <e:ArrowSeparated> ")" => (v, e)
}

IndSpecsDecl: ModuleItem = {
  "inductive" <typename: Ident> <ps: SimpleBind+> ":" <ar: ArrowSeparated> ":=" <ctors: Ctor+> => ModuleItem::Inductive {
    type_name: typename,
    parameter: ps,
    arity: Box::new(ar),
    constructors: ctors,
  }
}

Ctor: (Identifier, SExp) = {
  "|" <n: Ident> ":" <e: ArrowSeparated> ";" => (n, e)
}

DefDecl: ModuleItem = {
  "definition" <n: Ident> ":" <tyast: ArrowSeparated> ":=" <bdast: ArrowSeparated> ";" => ModuleItem::Definition {
    var: n,
    ty: tyast,
    body: bdast,
  }
}

ModItem: ModuleItem = {
  IndSpecsDecl,
  DefDecl,
}

SimpleBindSemicolon: (Identifier, SExp) = {
  <v: Ident> ":" <e:ArrowSeparated> ";" => (v, e)
}

ModuleRep: Module = {
  "module" <nameast: Ident> "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: vec![], declarations: decls },
  "module" <nameast: Ident> "(" <sb: SimpleBindSemicolon+> ")" "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: sb, declarations: decls },
}

pub ModuleReps: Vec<Module> = {
  ModuleRep*
}
*/