use crate::syntax::{Identifier, SExp, MacroToken, Bind, Module, ModuleItem, MacroExp};
use crate::utils::assoc_apply_vec;
use either::Either;
use lalrpop_util::ParseError;
use std::str::FromStr;

grammar;

pub SortAst: kernel::exp::Sort = {
  "\\Prop" => kernel::exp::Sort::Prop,
  "\\PropKind" => kernel::exp::Sort::PropKind,
  "\\Set" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
  "\\SetKind" "(" <n: num> ")" => kernel::exp::Sort::Set(n),
}

Ident: Identifier = {
  <s:r"[a-zA-Z][a-zA-Z0-9_]*"> => Identifier(String::from(s)),
}

num: usize = {
  <s:r"[0-9]+"> => usize::from_str(s).unwrap(),
}

MacTok: MacroToken = {
  <n: num> => MacroToken(n.to_string()),
  <s:r"[#$%]+"> => MacroToken(String::from(s)),
}

pub SExpAll: SExp = {
  ArrowSeparated,
}

pub ArrowSeparated: SExp = {
  <bdast: Binder> "->" <bodyast: ArrowSeparated> => SExp::Prod { bind: bdast, body: Box::new(bodyast)},
  <bdast: Binder> "=>" <bodyast: ArrowSeparated> => SExp::Lam { bind: bdast, body: Box::new(bodyast)},
  <a: Atom+> => assoc_apply_vec(a),
  AtomParen,
}

AtomParen: SExp = {
  "(" <e: ArrowSeparated> ")" => e,
  "$(" <seq: MacAst+> "$)"  => SExp::MathMacro { tokens: Box::new(MacroExp::Seq(seq)) },
  "!" <nameast: Ident> "{" <seq: MacAst+> "}" => SExp::NamedMacro { name: nameast, tokens: Box::new(MacroExp::Seq(seq)) },
}

Atom: SExp = {
  <s: SortAst> => SExp::Sort(s),
  <v0: Ident> => SExp::AccessPath(vec![v0]),
  <v0: Ident> "." <v1: Ident> => SExp::AccessPath(vec![v0, v1]),
  <v0: Ident> "." <v1: Ident> "." <v2: Ident> => SExp::AccessPath(vec![v0, v1, v2]),
}

Binder: Bind = {
  "(" <v: Ident> ":" <e: ArrowSeparated> ")" => Bind::Named { var: v, ty: Box::new(e) },
  "(" <v: Ident> ":" <e: ArrowSeparated> "|" <pre: ArrowSeparated> ")" => Bind::Subset { var: v, ty: Box::new(e), predicate: Box::new(pre) },
  "(" <v: Ident> ":" <e: ArrowSeparated> "|" <p: Ident> ":" <pre: ArrowSeparated> ")" => Bind::SubsetWithProof { var: v, ty: Box::new(e), predicate: Box::new(pre), proof: p },
  <e: Atom> => Bind::Anonymous { ty: Box::new(e) },
  <e: AtomParen> => Bind::Anonymous { ty: Box::new(e) },
}

MacAst: MacroExp = {
  "(" <e: ArrowSeparated+> ")" => {
    let tok: Vec<_> = e.into_iter().map(|tok| MacroExp::Exp(tok)).collect::<Vec<_>>();
    MacroExp::Seq(tok)
  },
  <a: Atom> => MacroExp::Exp(a),
  <tok: MacTok> => MacroExp::Tok(tok),
}

SimpleBind: (Identifier, SExp) = {
  "(" <v: Ident> ":" <e:ArrowSeparated> ")" => (v, e)
}

IndSpecsDecl: ModuleItem = {
  "inductive" <typename: Ident> <ps: SimpleBind+> ":" <ar: ArrowSeparated> ":=" <ctors: Ctor+> => ModuleItem::Inductive {
    type_name: typename,
    parameter: ps,
    arity: Box::new(ar),
    constructors: ctors,
  }
}

Ctor: (Identifier, SExp) = {
  "|" <n: Ident> ":" <e: ArrowSeparated> ";" => (n, e)
}

DefDecl: ModuleItem = {
  "definition" <n: Ident> ":" <tyast: ArrowSeparated> ":=" <bdast: ArrowSeparated> ";" => ModuleItem::Definition {
    var: n,
    ty: tyast,
    body: bdast,
  }
}

ModItem: ModuleItem = {
  IndSpecsDecl,
  DefDecl,
}

SimpleBindSemicolon: (Identifier, SExp) = {
  <v: Ident> ":" <e:ArrowSeparated> ";" => (v, e)
}

ModuleRep: Module = {
  "module" <nameast: Ident> "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: vec![], declarations: decls },
  "module" <nameast: Ident> "(" <sb: SimpleBindSemicolon+> ")" "{" <decls: ModItem*> "}" => crate::syntax::Module { name: nameast, parameters: sb, declarations: decls },
}

pub ModuleReps: Vec<Module> = {
  ModuleRep*
}
