Def prod: ((a: SET) -> (b: SET) -> SET) :=
    (\a: SET. \b: SET.  (c: SET) -> (_: (_: a) -> (_: a) -> c) -> c)
/* SET is predicative so it fails
[ a: SET, b: SET |- ((c: SET) -> (_: ...) -> c): SET ]
needs (TYPE, SET) in rel
*/ ;

Inductive Bool: SET with
    | True: Bool
    | False: Bool
;

Def if_statement: (a: SET) -> (x1: a) -> (x2: a) -> (b: Bool) -> a :=
    \a: SET . \x1: a . \x2: a. \b: Bool.  
    elim(Bool) b return \b: Bool. a with
    | True => x1
    | False => x2
    end
;

Def if_statement2: (a: TYPE) -> (x1: a) -> (x2: a) -> (b: Bool) -> a :=
    \a: TYPE . \x1: a . \x2: a. \b: Bool.  
    elim(Bool) b return \b: Bool. a with
    | True => x1
    | False => x2
    end
/* TYPE: ? がないので失敗する*/;

Def prod_bool_form: ((a: SET) -> (b: SET) -> SET) :=
    \a: SET. \b: SET.
    (c: Bool) -> elim(Bool) c return \c: Bool. SET with
    | True => a
    | False => b
    end
/* こっちは成功するんだ */;

Def prod_bool_intro:
    ((a: SET) -> (b: SET) -> (x: a) -> (y: b) -> prod_bool_form a b) :=
    \a: SET. \b: SET. \x: a. \y: b.
    /* (c: Bool) -> elim(Bool) c return \c: Bool. SET with ... end
    return がわからない。
    */
    \c: Bool.
    elim(Bool) c return
        elim(Bool) c return \c: Bool. SET with
        | True => a
        | False => b
        end
    with
    | True => x
    | False => y
    end
;
